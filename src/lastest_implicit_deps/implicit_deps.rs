use move_package::source_package::parsed_manifest::{
    Dependencies, Dependency, DependencyKind, GitInfo, InternalDependency,
};

use regex::Regex;
use serde::{Deserialize, Serialize};

use std::collections::BTreeMap;
use std::fs;
use std::str::FromStr;

use move_package::source_package::parsed_manifest::SourceManifest;

pub const SYSTEM_GIT_REPO: &str = "https://github.com/MystenLabs/sui.git";

#[derive(
    Clone, Copy, Debug, Default, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize,
)]
pub struct ProtocolVersion(u64);

impl ProtocolVersion {
    pub fn new(version: u64) -> Self {
        Self(version)
    }
    pub fn value(&self) -> u64 {
        self.0
    }
    pub const MAX: Self = Self(u64::MAX);
}

impl FromStr for ProtocolVersion {
    type Err = anyhow::Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(Self(s.parse()?))
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct SystemPackagesVersion {
    pub git_revision: String,
    pub packages: Vec<SystemPackage>,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct SystemPackage {
    pub package_name: String,
    pub repo_path: String,
    pub id: String,
}

/// Create a set of [Dependencies] from a [SystemPackagesVersion]; the dependencies are override git
/// dependencies to the specific revision given by the [SystemPackagesVersion]
///
/// Skips "Deepbook" dependency.
pub fn implicit_deps() -> Dependencies {
    let deps_to_skip = ["DeepBook".to_string()];
    let packages = latest_system_packages();
    let Some(git_revision) = get_latest_sui_commit_in_move_home() else {
        println!("cant found any git_revision in MOVEHOME");
        return Default::default();
    };
    println!("git_revision for implicit dep: {}", git_revision);
    packages
        .packages
        .iter()
        .filter(|package| !deps_to_skip.contains(&package.package_name))
        .map(|package| {
            (
                package.package_name.clone().into(),
                Dependency::Internal(InternalDependency {
                    kind: DependencyKind::Git(GitInfo {
                        git_url: SYSTEM_GIT_REPO.into(),
                        git_rev: git_revision.clone().into(),
                        subdir: package.repo_path.clone().into(),
                    }),
                    subst: None,
                    digest: None,
                    dep_override: true,
                }),
            )
        })
        .collect()
}

fn latest_system_packages() -> SystemPackagesVersion {
    // Static mapping from protocol versions to the metadata for the system packages
    // Generated by [generate_system_packages_version_table] in build.rs
    let version_table: BTreeMap<ProtocolVersion, SystemPackagesVersion> =
        BTreeMap::from(include!("system_packages/system_packages_version_table.rs"));
    version_table
        .last_key_value()
        .expect("known system package version table should be nonempty")
        .1
        .clone()
}

fn find_latest_commit(path: &str, _repo: &str) -> Option<String> {
    let re = Regex::new(r"https___github_com_MystenLabs_sui_git_([0-9a-f]{40})").ok()?;
    for entry in fs::read_dir(path).ok()? {
        let entry = entry.ok()?;
        let name = entry.file_name().into_string().ok()?;

        if let Some(cap) = re.captures(&name) {
            return Some(cap[1].to_string());
        }
    }
    None
}

pub fn get_latest_sui_commit_in_move_home() -> Option<String> {
    return find_latest_commit(crate::project::MOVE_HOME, "MystenLabs/sui");
}

pub fn merge_implicit_deps_to_manifest(manifest: &SourceManifest) -> Dependencies {
    let mut implicit_deps = implicit_deps();
    println!("implicit_deps: {:?}", implicit_deps);
    let mut merged = manifest.dev_dependencies.clone();
    for (k, v) in manifest.dependencies.iter() {
        merged.entry(*k).or_insert(v.clone()); // 如果 key 已经存在，不覆盖
    }

    let mut implicit_version_in_mani_dep = None;
    for (pkg_name, d) in implicit_deps.iter() {
        if merged.contains_key(pkg_name) {
            implicit_version_in_mani_dep = Some(d.clone());
        }
    }

    // if sui-framework have been in manifest,
    if let Some(dep) = implicit_version_in_mani_dep {
        let Dependency::Internal(i) = dep else {
            return merged;
        };

        let DependencyKind::Git(g) = &i.kind else {
            return merged;
        };

        for d in implicit_deps.iter_mut() {
            if let Dependency::Internal(i) = d.1 {
                if let DependencyKind::Git(g2) = &mut i.kind {
                    g2.git_rev = g.git_rev.clone();
                }
            }
        }
    }

    for (k, v) in implicit_deps.iter() {
        merged.entry(*k).or_insert(v.clone());
    }
    merged
}
